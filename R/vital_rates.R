#' Calculate median, minimum, and maximum age at first reproduction
#'
#' @param b Name of the tbl_df containing biography data generated by the function read_bio_table.
#' @return Output is a tbl_df that gives the median, minimum, and maximum age at first reproduction for each study species in days and years. Sample size is also included.
#' @export
#' @examples
#' afr <- age_first_rep(lh)
age_first_rep <- function(b){

  # Find all animals that are first born offspring
  # Since there are currently errors in the first-born column,
  # choose the first offspring for each mother that is called her first-born
  fb <- b %>%
    dplyr::filter(First.Born == "Y") %>%
    dplyr::group_by(Study.Id, Mom.Id) %>%
    dplyr::arrange(Birth.Date) %>%
    dplyr::summarise(Animal.Id = dplyr::first(Animal.Id),
              Birth.Date = dplyr::first(Birth.Date),
              Sex = dplyr::first(Sex),
              First.Born = dplyr::first(First.Born)) %>%
    dplyr::select(Study.Id, Animal.Id, Birth.Date, Mom.Id, First.Born, Sex)

  # Create a temporary data frame of mothers of these animals with their birth dates
  # Note that cases where Mom.Id doesn't match exactly with Animal.Id are dropped silently
  # Use find_mom_errors() function to find these cases!
  mothers <- suppressWarnings(dplyr::semi_join(b, fb,
                                               by = c("Study.Id" = "Study.Id",
                                                      "Animal.Id" = "Mom.Id")))
  mothers <- mothers %>%
    dplyr::select(Study.Id, Animal.Id, Birth.Date) %>%
    dplyr::rename(Mother.Birth.Date = Birth.Date)

  # For first-born animals in fb, get the mother's birth date using inner join
  temp <- suppressWarnings(dplyr::inner_join(fb, mothers, by = c("Study.Id" = "Study.Id",
                                                                 "Mom.Id" = "Animal.Id")))

  # Calculate mother's age when the first offspring was born
  ages <- temp %>%
    dplyr::mutate(age_days = as.numeric(Birth.Date - Mother.Birth.Date),
                  age_years = as.numeric(difftime(Birth.Date, Mother.Birth.Date) / 365.25)) %>%
    dplyr::group_by(Study.Id) %>%
    dplyr::summarise(median_age_days = median(age_days),
                     median_age_years = median(age_years),
                     minimum_age_days = min(age_days),
                     minimum_age_years = min(age_years),
                     maximum_age_days = max(age_days),
                     maximum_age_years = max(age_years),
                     n_first_births = n())

  return(ages)
}


#' Calculate age-specific fertility
#' Based on Bill Morris' methods for calculating vital rates, available on the Wiki.
#'
#' @param b Name of the tbl_df containing biography data generated by the function read_bio_table.
#' @param f Name of the tbl_df containing fertility data generated by the function read_fert_table.
#' @return Output is a tbl_df that includes the per capita fertility for each discrete age class for each study species. Also included are the number of animals and the "female-years" of observation on which the calculation is based.
#' @export
#' @examples
#' asf <- age_specific_fertility(lh, fert)
age_specific_fertility <- function(b, f){

  f$Animal.Id <- as.character(f$Animal.Id)
  b$Animal.Id <- as.character(b$Animal.Id)

  # For each female in f (fertility), find her birth date
  # Easily done with an inner join of the two tables
  # Joined on Study.Id and Animal.Id (because some duplication of Animal.Id)
  temp <- dplyr::inner_join(b, f, by = c("Study.Id" = "Study.Id",
                                         "Animal.Id" = "Animal.Id"))

  # Create columns for first and last birthday, and fill with dummy dates
  temp <- dplyr::mutate(temp, FirstBirthday = lubridate::ymd("1900-01-01"),
                 LastBirthday = lubridate::ymd("1900-01-01"))

  # Find the end of each study
  study_end <- b %>%
    dplyr::group_by(Study.Id) %>%
    dplyr::summarise(Study.End = max(Depart.Date))

  # Use another inner join to put the end of study date in the working data frame
  temp <- suppressMessages(dplyr::inner_join(temp, study_end))

  # Create blank list to hold output
  asf <- list()

  # Loop through all entries in working data frame
  for (i in 1:nrow(temp)){

    # Store these values temporarily for future use in matching
    s <- temp[i, ]$Study.Id
    m <- temp[i, ]$Animal.Id

    actual_bd <- temp[i, ]$Birth.Date

    # For now, set end birthday to the birthday on the year that the study ends
    end_bd <- lubridate::ymd(paste(lubridate::year(temp[i, ]$Study.End),
                                    lubridate::month(temp[i, ]$Birth.Date),
                                    lubridate::day(temp[i, ]$Birth.Date),
                                    sep = "-"))

    # If the date of end birthday is before the date of study end,
    # add one year to the end birthday
    if (temp[i, ]$Study.End > end_bd){
      end_bd <- end_bd + lubridate::years(1)
    }

    # Compute dates of the current female's birthdays from year of birth to
    # end birthday determined above
    bd <- seq(actual_bd, end_bd, "1 year")

    # The "FirstBirthday" to be used for fertility analysis is the latest
    # birthday before or on the first date of fertility observation
    first_bd <- max(bd[bd <= temp[i, ]$Start.Date])

    # The "LastBirthday" to be used for fertility analysis is the earliest
    # birthday on or after the last date of fertility observation
    last_bd <- min(bd[bd >= temp[i, ]$Stop.Date])

    # Recalculate the birthday sequence using first and last birthdays
    bd <- seq(first_bd, last_bd, "1 year")

    # Temporary data frame to hold the fertility data for the current female
    # Has one record for each one-year interval between the female's birthdays
    asf_i <- data.frame(Study.Id = temp[i, ]$Study.Id,
                        Animal.Id = temp[i, ]$Animal.Id,
                        Birth.Date = temp[i, ]$Birth.Date,
                        Start.Date = temp[i, ]$Start.Date,
                        Stop.Date = temp[i, ]$Stop.Date,
                        Last.BD = bd[1:(length(bd) - 1)],
                        Next.BD = bd[2:length(bd)],
                        Weight = NA,
                        Num.Offspring = NA)

    # Calculate weight of first year based on fraction of year actually observed
    if (asf_i[1, ]$Last.BD < asf_i[1, ]$Start.Date){
      asf_i[1, ]$Weight <- (asf_i[1, ]$Next.BD - asf_i[1, ]$Start.Date) / 365.25
    }

    # Calcualte weight of last year based on fraction of year actually observed
    k <- nrow(asf_i)
    if (asf_i[k, ]$Next.BD > asf_i[k, ]$Stop.Date){
      asf_i[k, ]$Weight <- (asf_i[k, ]$Stop.Date - asf_i[k, ]$Last.BD) / 365.25
    }

    # Set all other weights to 1 because fertility was observed for complete year
    if (nrow(asf_i[is.na(asf_i$Weight), ]) > 0){
      asf_i[is.na(asf_i$Weight), ]$Weight <- 1
    }

    # Calculate discrete age class (i.e., age in years)
    asf_i$Discrete.Age.Class <- lubridate::year(asf_i$Last.BD) - lubridate::year(asf_i$Birth.Date)

    # Loop over current female's birthdays and add up number of individuals born
    # to that female in that year
    for (j in 1:nrow(asf_i)){
      asf_i[j, ]$Num.Offspring <- b %>%
        dplyr::filter(Study.Id == s & Mom.Id == m &
                        Birth.Date >= asf_i[j, ]$Last.BD &
                        Birth.Date < asf_i[j, ]$Next.BD) %>%
        nrow()
    }

    # Add this data frame to the larger list
    asf[[i]] <- asf_i
  }

  # Bind all rows of the list together into one tbl_df
  asf <- suppressWarnings(dplyr::bind_rows(asf))

  # Compute average age-specific per-capita fertility
  asf_summary <- asf %>%
    dplyr::group_by(Study.Id, Discrete.Age.Class) %>%
    dplyr::summarise(n_animals = n(),
                     female_years = sum(Weight),
                     f = sum(Num.Offspring * Weight) / sum(Weight))

  return(asf_summary)
}


#' Calculate stage-specific survival
#' Based on Bill Morris' methods for calculating vital rates, available on the Wiki.
#'
#' @param b Name of the tbl_df containing biography data generated by the function read_bio_table.
#' @return Output is a tbl_df that includes the probability of survival for each life-history stage for each study species. Life history stages include newborns, juveniles, and adults; these are defined as in Morris et al. 2011. Also included are the number of animals and the "animal-years" of observation on which the calculation is based.
#' @export
#' @examples
#' sss <- stage_specific_survival(lh)
stage_specific_survival <- function(b, adult_definition = "median"){

  if (!adult_definition %in% c("median", "minimum")){
    stop("Unrecognized definition for adult females (must be 'median' or 'minimum').")
  }

  b$Animal.Id <- as.character(b$Animal.Id)

  # For now, because of database issues, there are some individuals
  # for which Depart.Date < Entry.Date
  # Need to filter these out
  b <- filter(b, Depart.Date >= Entry.Date)

  # Get life history stage (newborn, juvenile, or adult) of each animal at each
  # pseudocensus date during the study
  ps_ages <- pseudocensus_ages(b, adult_definition)

  # Remove years for which census_end < Entry.Date or census_date > Depart.Date
  ps_ages <- ps_ages %>%
    dplyr:: mutate(census_date = ymd(census_date),
                   census_end = census_date + lubridate::years(1)) %>%
    dplyr::filter(census_end > Entry.Date & census_date <= Depart.Date)

  animals <- ps_ages %>%
    distinct(Study.Id, Animal.Id) %>%
    select(Study.Id, Animal.Id)

  m <- list()

  for (i in 1:nrow(animals)){

    temp_study <- animals[i, ]$Study.Id
    temp_animal <- animals[i, ]$Animal.Id

    temp_set <- ps_ages %>%
      filter(Study.Id == temp_study & Animal.Id == temp_animal) %>%
      mutate(Alive = 0, Deaths = 0) %>%
      arrange(census_date)

    for (j in 1:nrow(temp_set)){

      # Weight starts at zero
      w <- 0

      # MinCensus is a special case for which the weight has to be adjusted
      if (j == 1){

        # Non-newborns
        if (temp_set[j, ]$discrete_age_class != 0){

          # Individual survives to next census
          if (temp_set[j, ]$Depart.Date > temp_set[j, ]$census_date + lubridate::years(1)){

            # Weight is 1 if entry date equals census date
            if (temp_set[j, ]$Entry.Date == temp_set[j, ]$census_date){
              w <- 1
            }
            # Otherwise, weight is next census date - entry date / 365.25
            else{
              w <- difftime(temp_set[j, ]$census_date + lubridate::years(1),
                            temp_set[j, ]$Entry.Date,
                            units = "days") / 365.25
            }
          }

          # Individual not present at next census
          # This means there is only one entry for the animal, i.e. nrow(temp_set) == 1
          else{
            w <- difftime(temp_set[j, ]$Depart.Date,
                          temp_set[j, ]$Entry.Date,
                          units = "days") / 365.25

            # Individual died before next census
            if (temp_set[j, ]$Depart.Type == "D"){
              temp_set[j, ]$Deaths <- w
            }
          }
        }

        # Newborns
        else if (temp_set[j, ]$discrete_age_class == 0){

          # Infant survives to next census
          if (temp_set[j, ]$Depart.Date >= temp_set[j, ]$census_date + lubridate::years(1)){
            w <- 1
          }

          # Infant not present at next census
          # This means there is only one entry for the animal, i.e. nrow(temp_set) == 1
          else{
            if (temp_set[j, ]$Depart.Type %in% c("E", "O", "P")){

              w <- difftime(temp_set[j, ]$Depart.Date,
                            temp_set[j, ]$census_date,
                            units = "days") / 365.25
            }

            # Infant died before next census
            else if (temp_set[j, ]$Depart.Type == "D"){
              w <- 1
              temp_set[j, ]$Deaths <- w
            }
          }
        }
      }

      # MaxCensus (when nrow(temp_set) > 1)
      else if (j > 1 & j == nrow(temp_set)){
        if (temp_set[j, ]$Depart.Type == "D"){
          w <- 1
          temp_set[j, ]$Deaths <- w
        }
        else{
          w <- difftime(temp_set[j, ]$Depart.Date,
                        temp_set[j, ]$census_date,
                        units = "days") / 365.25
        }

      }

      # All other census dates
      else{
        w <- 1
      }

      temp_set[j, ]$Alive <- w
    }

    m[[i]] <- temp_set
  }

  m <- bind_rows(m)

  sss_summary <- m %>%
    dplyr::mutate(year_of = lubridate::year(census_date)) %>%
    dplyr::group_by(Study.Id, year_of, age_class) %>%
    dplyr::summarise(n_animals = n(),
                     individual_years = sum(Alive),
                     s = 1 - (sum(Deaths) / sum(Alive)),
                     deaths = sum(Deaths),
                     trials = round(individual_years, 0),
                     successes = round(individual_years, 0) - round(deaths, 0))
}


#' Calculate stage-specific fertility
#' Based on Bill Morris' methods for calculating vital rates, available on the Wiki.
#'
#' @param b Name of the tbl_df containing biography data generated by the function read_bio_table.
#' @param f Name of the tbl_df containing fertility data generated by the function read_fert_table.
#' @param f Logical. Should the fertility be calculated for each year separately?
#' @return Output is a tbl_df that includes the per capita fertility for each life-history stage for each study species. Life history stages include newborns, juveniles, and adults; these are defined as in Morris et al. 2011. Also included are the number of animals and the "female-years" of observation on which the calculation is based.
#' @export
#' @examples
#' ssf <- stage_specific_fertility(lh, fert)
stage_specific_fertility <- function(b, f, adult_definition = "median", annual = TRUE){

  if (!adult_definition %in% c("median", "minimum")){
    stop("Unrecognized definition for adult females (must be 'median' or 'minimum').")
  }

  f$Animal.Id <- as.character(f$Animal.Id)
  b$Animal.Id <- as.character(b$Animal.Id)

  # Get subset of animals for which fertility was monitored
  # Semi-join retains all rows in b that have a match in f
  temp <- dplyr::semi_join(b, f, by = c("Study.Id" = "Study.Id",
                                        "Animal.Id" = "Animal.Id"))

  # Get life history stage (newborn, juvenile, or adult) of each animal at each
  # pseudocensus date during the study
  ps_ages <- pseudocensus_ages(temp, adult_definition)

  # Join to fertility data to get start and stop dates
  ps_ages <- dplyr::inner_join(ps_ages, f, by = c("Study.Id" = "Study.Id",
                                                  "Animal.Id" = "Animal.Id"))

  ps_ages$Weight <- NA
  ps_ages$Num.Offspring <- NA

  # Remove years for which census_end < Start.Date or census_date > End.Date
  ps_ages <- ps_ages %>%
    dplyr:: mutate(census_date = lubridate::ymd(census_date),
                   census_end = census_date + lubridate::years(1)) %>%
    dplyr::filter(census_end > Start.Date & census_date <= Stop.Date)

  # Calculate weight as the proportion of the psuedocensus year for which
  # the female's fertility was observed
  # Takes about 2 minutes to run
  for (i in 1:nrow(ps_ages)){

    # Store these values temporarily for future use in matching
    s <- as.character(ps_ages[i, ]$Study.Id)
    m <- as.character(ps_ages[i, ]$Animal.Id)

    # If start date and end date fully encompass census year, weight is 1
    if (ps_ages[i, ]$census_date >= ps_ages[i, ]$Start.Date &
       ps_ages[i, ]$census_end <= ps_ages[i, ]$Stop.Date){
      ps_ages[i, ]$Weight <- 1
    }

    # Else if census date before start date, fertility observation is censored
    # Get length between start date and min of {census end, stop date}
    else if (ps_ages[i, ]$census_date < ps_ages[i, ]$Start.Date){
      ps_ages[i, ]$Weight <- (min(c(ps_ages[i, ]$census_end,
                                    ps_ages[i, ]$Stop.Date)) -
                                ps_ages[i, ]$Start.Date) / 365.25
    }

    # Else if stop date is before next census, fertility observation is censored
    # Get length between max of {census start, start date} and stop date
    else if (ps_ages[i, ]$Stop.Date < ps_ages[i, ]$census_end){
      ps_ages[i, ]$Weight <- (ps_ages[i, ]$Stop.Date -
        (max(c(ps_ages[i, ]$census_date, ps_ages[i, ]$Start.Date)))) / 365.25
    }

    t1 <- ps_ages[i, ]$census_date
    t2 <- ps_ages[i, ]$census_end

    # Add up the number of individuals born to
    # that female in that census year
    ps_ages[i, ]$Num.Offspring <- b %>%
      dplyr::filter(Study.Id == s & Mom.Id == m & Birth.Date >= t1 & Birth.Date < t2) %>%
      nrow()
  }

  if (annual){
    # Compute annual stage-specific per-capita fertility
    ssf_summary <- ps_ages %>%
      dplyr::mutate(year_of = lubridate::year(census_date)) %>%
      dplyr::group_by(Study.Id, year_of, age_class) %>%
      dplyr::summarise(n_animals = n(),
                       female_years = sum(Weight),
                       f = sum(Num.Offspring * Weight) / sum(Weight),
                       trials = round(female_years, 0),
                       successes = round(sum(Num.Offspring * Weight), 0))
  }
  else{
    # Compute average stage-specific per-capita fertility across all years
    ssf_summary <- ps_ages %>%
      dplyr::group_by(Study.Id, age_class) %>%
      dplyr::summarise(n_animals = n(),
                       female_years = sum(Weight),
                       f = sum(Num.Offspring * Weight) / sum(Weight),
                       trials = round(female_years, 0),
                       successes = round(sum(Num.Offspring * Weight), 0))
  }

  return(ssf_summary)
}


#' Calculates the age class of an animal based on its age and the median age at
#' first reproduction for the species.
#'
#' @param age_years Age of the animal in years.
#' @param mafr Median age of first reproduction in years for the species.
#' @return Output is a character string: "newborn", "juvenile", or "adult"
#' @export
#' @examples
#' age_class <- get_age_class(5.1, 8.78589)
get_age_class <- function(age_years, mafr){

  res <- ifelse(age_years <= 0, "newborn",
                ifelse(age_years > 0 & age_years < mafr, "juvenile", "adult"))

  return(res)
}

#' Create pseudocensus dates and calculate ages of all animals present at each census.
#' This function is used by the stage-specific vital rate functions.
#'
#' @param b Name of the tbl_df containing biography data generated by the function read_bio_table.
#' @return Output is a tbl_df that includes an entry for each animal present at each pseudo-census date along with its discrete age class and life-history stage at that date.
#' @export
#' @examples
#' ages <- pseudocensus_ages(lh)
pseudocensus_ages <- function(b, adult_definition = "median"){

  if (!adult_definition %in% c("median", "minimum")){
    stop("Unrecognized definition for adult females (must be 'median' or 'minimum').")
  }

  # pseudocensus
  census <- b %>%
    dplyr::group_by(Study.Id) %>%
    dplyr::summarise(min_entry = min(Entry.Date)) %>%
    dplyr::mutate(census_start = lubridate::ymd(paste(year(min_entry),
                                                      "01", "01", sep = "-")))

  census_end <- b %>%
    dplyr::group_by(Study.Id) %>%
    dplyr::filter(Depart.Type == "O") %>%
    dplyr::summarise(study_end = max(Depart.Date)) %>%
    dplyr::mutate(census_end = lubridate::ceiling_date(study_end,
                                                       unit = "year") - lubridate::years(1))

  census <- suppressMessages(dplyr::inner_join(census, census_end))

  census_seq <- function(df) {
    seq(df$census_start, df$census_end, "1 year")
  }

  census_dates <- plyr::dlply(census, .(Study.Id), census_seq)

  mafr <- age_first_rep(b)

  # For each census date, calculate the age of each animal present
  age_df <- list()
  for (j in 1:7){
    site <- as.character(census[j, ]$Study.Id)
    site_seq <- census_dates[[site]]
    temp_lh <- b %>%
      dplyr::filter(Study.Id == site)

    if (adult_definition == "median"){
      temp_mafr <- mafr[mafr$Study.Id == site, ]$median_age_years
    } else if (adult_definition == "minimum"){
      temp_mafr <- mafr[mafr$Study.Id == site, ]$minimum_age_years
    }

    ages <- list()
    for (i in 1:length(site_seq)){
      # For each date, extract subset of animals present or born before the next census
      t <- site_seq[i]

      temp_set <- temp_lh %>%
        dplyr::filter(Entry.Date - lubridate::years(1) < t & Depart.Date >= t)

      # If present, calculate age and assign to age category; calculate weight if neccesary
      ages[[i]] <- temp_set %>%
        dplyr::mutate(age_days = difftime(t, Birth.Date, units = "days"),
                      age_years = age_days / 365.25,
                      census_date = as.Date(t),
                      discrete_age_class = ceiling(age_years),
                      age_class = get_age_class(age_years, temp_mafr)) %>%
        dplyr::select(census_date, 1:4, age_days, age_years,
                      discrete_age_class, age_class, 13:16)
    }

    # site_ages <- do.call("rbind", ages)
    site_ages <- dplyr::bind_rows(ages)
    age_df[[j]] <- site_ages
  }

  # age_df <- do.call("rbind", age_df)
  age_df <- dplyr::bind_rows(age_df)

  return(age_df)
}

#' Converts the stage-specific survivorship data to binomial (trials & successes).
#'
#' @param df Name of the tbl_df containing survivorship data generated by the function stage_specific_survival.
#' @export
#' @examples
#' surv_trials <- make_survivorship_trials(sss)
make_survivorship_trials <- function(df){

  get_trials <- function(df){

    fates <- list()

    for (i in 1:nrow(df)){
      fate <- c(rep(1, df[i, ]$successes),
                rep(0, df[i, ]$trials - df[i, ]$successes))

      f <- data.frame(fate = fate)

      f$Study.Id <- df[i, ]$Study.Id
      f$year_of <- df[i, ]$year_of
      f$age_class <- df[i, ]$age_class

      fates[[i]] <- f
    }

    fates <- dplyr::bind_rows(fates)

    fates <- dplyr::select(fates, 2:4, 1)

    return(fates)
  }

  surv_trials <- bind_rows(plyr::dlply(filter(df, trials != 0),
                                       .(Study.Id, age_class),
                                       get_trials))

  surv_trials$age_class <- factor(surv_trials$age_class,
                                  levels = c("newborn", "juvenile", "adult"))

  return(surv_trials)
}