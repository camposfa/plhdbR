#' Calculate median age at first reproduction
#'
#' Returns a dplyr::tbl_df.
#'
#' @param b Name of the tbl_df containing biography data generated by the function read_bio_table.
#' @export
#' @examples
#' a <- median_age_first_rep(lh)
median_age_first_rep <- function(b){

  # Find all animals that are first born offspring
  # Since there are currently errors in the first-born column,
  # choose the first offspring for each mother that is called her first-born
  fb <- b %>%
    dplyr::filter(First.Born == "Y") %>%
    dplyr::group_by(Study.Id, Mom.Id) %>%
    dplyr::arrange(Birth.Date) %>%
    dplyr::summarise(Animal.Id = dplyr::first(Animal.Id),
              Birth.Date = dplyr::first(Birth.Date),
              Sex = dplyr::first(Sex),
              First.Born = dplyr::first(First.Born)) %>%
    dplyr::select(Study.Id, Animal.Id, Birth.Date, Mom.Id, First.Born, Sex)

  # Create a temporary data frame of mothers of these animals with their birth dates
  # Note that cases where Mom.Id doesn't match exactly with Animal.Id are dropped silently
  # Use find_mom_errors() function to find these cases!
  mothers <- suppressWarnings(dplyr::semi_join(b, fb,
                                               by = c("Study.Id" = "Study.Id",
                                                      "Animal.Id" = "Mom.Id")))
  mothers <- mothers %>%
    dplyr::select(Study.Id, Animal.Id, Birth.Date) %>%
    dplyr::rename(Mother.Birth.Date = Birth.Date)

  # For first-born animals in fb, get the mother's birth date using inner join
  temp <- suppressWarnings(dplyr::inner_join(fb, mothers, by = c("Study.Id" = "Study.Id",
                                                                 "Mom.Id" = "Animal.Id")))

  # Calculate mother's age when the first offspring was born
  med_age <- temp %>%
    dplyr::mutate(age_days = Birth.Date - Mother.Birth.Date,
                  age_years = lubridate::interval(Mother.Birth.Date,
                                                  Birth.Date) / eyears(1)) %>%
    dplyr::group_by(Study.Id) %>%
    dplyr::summarise(median_age_days = median(age_days),
                     median_age_years = median(age_years))

  return(med_age)
}


#' Calculate age-specific fertility
#'
#' Returns a dplyr::tbl_df.
#' Based on Bill Morris' methods for calculating vital rates, available on the Wiki.
#'
#' @param b Name of the tbl_df containing biography data generated by the function read_bio_table.
#' @param f Name of the tbl_df containing fertility data generated by the function read_fert_table.
#' @export
#' @examples
#' asf <- age_specific_fertility(lh, fert)
age_specific_fertility <- function(b, f){

  # For each female in f (fertility), find her birth date
  # Easily done with an inner join of the two tables
  # Joined on Study.Id and Animal.Id (because some duplication of Animal.Id)
  temp <- suppressMessages(suppressWarnings(dplyr::inner_join(b, f, by = c("Study.Id" = "Study.Id",
                                                                           "Animal.Id" = "Animal.Id"))))

  # Create columns for first and last birthday, and fill with dummy dates
  temp <- mutate(temp, FirstBirthday = lubridate::ymd("1900-01-01"),
                 LastBirthday = lubridate::ymd("1900-01-01"))

  # Find the end of each study
  study_end <- b %>%
    dplyr::group_by(Study.Id) %>%
    dplyr::summarise(Study.End = max(Depart.Date))

  # Use another inner join to put the end of study date in the working data frame
  temp <- suppressMessages(dplyr::inner_join(temp, study_end))

  # Create blank list to hold output
  asf <- list()

  # Loop through all entries in working data frame
  for(i in 1:nrow(temp)){

    # Store these values temporarily for future use in matching
    s <- temp[i, ]$Study.Id
    m <- temp[i, ]$Animal.Id

    actual_bd <- temp[i, ]$Birth.Date

    # For now, set end birthday to the birthday on the year that the study ends
    end_bd <- lubridate::ymd(paste(lubridate::year(temp[i, ]$Study.End),
                                    lubridate::month(temp[i, ]$Birth.Date),
                                    lubridate::day(temp[i, ]$Birth.Date),
                                    sep = "-"))

    # If the date of end birthday is before the date of study end,
    # add one year to the end birthday
    if(temp[i, ]$Study.End > end_bd){
      end_bd <- end_bd + lubridate::years(1)
    }

    # Compute dates of the current female's birthdays from year of birth to
    # end birthday determined above
    bd <- seq(actual_bd, end_bd, "1 year")

    # The "FirstBirthday" to be used for fertility analysis is the latest
    # birthday before or on the first date of fertility observation
    first_bd <- max(bd[bd <= temp[i, ]$Start.Date])

    # The "LastBirthday" to be used for fertility analysis is the earliest
    # birthday on or after the last date of fertility observation
    last_bd <- min(bd[bd >= temp[i, ]$Stop.Date])

    # Recalculate the birthday sequence using first and last birthdays
    bd <- seq(first_bd, last_bd, "1 year")

    # Temporary data frame to hold the fertility data for the current female
    # Has one record for each one-year interval between the female's birthdays
    asf_i <- data.frame(Study.Id = temp[i, ]$Study.Id,
                        Animal.Id = temp[i, ]$Animal.Id,
                        Birth.Date = temp[i, ]$Birth.Date,
                        Start.Date = temp[i, ]$Start.Date,
                        Stop.Date = temp[i, ]$Stop.Date,
                        Last.BD = bd[1:(length(bd) - 1)],
                        Next.BD = bd[2:length(bd)],
                        Weight = NA,
                        Num.Offspring = NA)

    # Calculate weight of first year based on fraction of year actually observed
    if(asf_i[1, ]$Last.BD < asf_i[1, ]$Start.Date){
      asf_i[1, ]$Weight <- (asf_i[1, ]$Next.BD - asf_i[1, ]$Start.Date) / 365.25
    }

    # Calcualte weight of last year based on fraction of year actually observed
    k <- nrow(asf_i)
    if(asf_i[k, ]$Next.BD > asf_i[k, ]$Stop.Date){
      asf_i[k, ]$Weight <- (asf_i[k, ]$Stop.Date - asf_i[k, ]$Last.BD) / 365.25
    }

    # Set all other weights to 1 because fertility was observed for complete year
    if(nrow(asf_i[is.na(asf_i$Weight), ]) > 0){
      asf_i[is.na(asf_i$Weight), ]$Weight <- 1
    }

    # Calculate discrete age class (i.e., age in years)
    asf_i$Discrete.Age.Class <- lubridate::year(asf_i$Last.BD) - lubridate::year(asf_i$Birth.Date)

    # Loop over current female's birthdays and add up number of individuals born
    # to that female in that year
    for(j in 1:nrow(asf_i)){
      asf_i[j, ]$Num.Offspring <- b %>%
        dplyr::filter(Study.Id == s & Mom.Id == m &
                        Birth.Date >= asf_i[j, ]$Last.BD &
                        Birth.Date < asf_i[j, ]$Next.BD) %>%
        nrow()
    }

    # Add this data frame to the larger list
    asf[[i]] <- asf_i
  }

  # Bind all rows of the list together into one tbl_df
  asf <- suppressWarnings(bind_rows(asf))

  # Compute average age-specific per-capita fertility
  asf_summary <- asf %>%
    group_by(Study.Id, Discrete.Age.Class) %>%
    summarise(f = sum(Num.Offspring * Weight) / sum(Weight),
              n = n())

  return(asf_summary)
}

#' Calculate stage-specific fertility between censuses
#' Based on Bill Morris' methods for calculating vital rates, available on the Wiki.
#'
#' Returns a dplyr::tbl_df.
#'
#' @param b Name of the tbl_df containing biography data generated by the function read_bio_table.
#' @param f Name of the tbl_df containing fertility data generated by the function read_fert_table.
#' @export
#' @examples
#' ssf <- stage_specific_fertility(lh, fert)
stage_specific_fertility <- function(b, f){



  return(ssf)
}